# 124. Binary Tree Maximum Path Sum

这道题的困难之处在于得到self.result的时候全部情况的cover，和在helper function返回深度的时候和取self.result不同 不能加入`max(left + right + root.val)`因为这个不可以返回，这不是一个path

```text
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        import sys
        self.result = -sys.maxsize
        if not root:
            return 0
        self.helper(root)
        return self.result
    def helper(self, root):
        if not root:
            return 0
        left = self.helper(root.left)
        right = self.helper(root.right) 
        //这里如何取max是重点啊
        self.result = max(max(self.result, max(left + right + root.val, max(left + root.val, right + root.val))), root.val)
        //这里如何return也是重点啊
        return max(root.val, max(left + root.val, right + root.val))
```

有一个更加elegant的做法哈哈，如果左右子树是负的话，就设为0，直接就不算入接下来的加和，这样的话去self.result的时候，可以左右子树直接相加不做判断，他可以是从左边到右边，也可以是从底部到顶部的树。同理再返回的时候直接加起来就可以了。值得注意的是当所有的数都是负的时候，他也是handle的住的。这么牛逼我怎么想到，哎。

```text
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        import sys
        self.result = -sys.maxsize
        if not root:
            return 0
        self.helper(root)
        return self.result
    def helper(self, root):
        if not root:
            return 0
        left = max(self.helper(root.left), 0)
        right = max(self.helper(root.right), 0)
        self.result = max(self.result, left + right + root.val)
        return root.val + max(left, right)
```

